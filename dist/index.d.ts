// Generated by dts-bundle-generator v5.9.0

export declare function getRandomInt(min: number, max: number): number;
export declare function getRandomFloat(min: number, max: number): number;
export declare function getRandomArrayElement<T>(arr: T[]): T;
export declare function radToDeg(rad: number): number;
export declare function degToRad(deg: number): number;
export declare function getDistance2D(x1: number, y1: number, x2: number, y2: number): number;
export declare function getDistance3D(x1: number, y1: number, z1: number, x2: number, y2: number, z2: number): number;
export declare function clamp(v: number, min: number, max: number): number;
export declare function lerp(v0: number, v1: number, t: number): number;
export declare function smoothstep(v: number, min: number, max: number, perlin: false): number;
export declare function isPowerOf2(value: number): boolean;
export interface NumberElements extends Iterable<number> {
	readonly length: number;
	toArray(): number[];
	toIntArray(): Int32Array;
	toFloatArray(): Float32Array;
}
export interface Vec extends NumberElements {
	clone(): Vec;
	addScalar(s: number): Vec;
	multiplyByScalar(s: number): Vec;
	normalize(): Vec;
	truncate(decimalDigits: number): Vec;
	getMagnitude(): number;
}
export interface Mat extends NumberElements {
	reset(): Mat;
	clone(): Mat;
	invert(): Mat;
	transpose(): Mat;
	truncate(decimalDigits: number): Mat;
	getDeterminant(): number;
}
export declare type EulerRotationOrder = "XYZ" | "ZYX" | "YZX" | "XZY" | "ZXY" | "YXZ";
export declare class EulerAngles {
	x: number;
	y: number;
	z: number;
	order: EulerRotationOrder;
	constructor(x?: number, y?: number, z?: number, order?: EulerRotationOrder);
	static fromEuler(ea: EulerAngles): EulerAngles;
	static fromRotationMatrix(m: Mat, order: EulerRotationOrder): EulerAngles;
	static equals(ea1: EulerAngles, ea2: EulerAngles): boolean;
	clone(): EulerAngles;
	set(x: number, y: number, z: number, order?: EulerRotationOrder): EulerAngles;
	setFromEuler(ea: EulerAngles): EulerAngles;
	equals(ea: EulerAngles): boolean;
	setFromRotationMatrix(m: Mat, order: EulerRotationOrder): EulerAngles;
}
export declare class Vec2 implements Vec {
	readonly length = 2;
	x: number;
	y: number;
	constructor(x?: number, y?: number);
	static multiplyByScalar(v: Vec2, s: number): Vec2;
	static addScalar(v: Vec2, s: number): Vec2;
	static normalize(v: Vec2): Vec2;
	static add(v1: Vec2, v2: Vec2): Vec2;
	static subtract(v1: Vec2, v2: Vec2): Vec2;
	static dotProduct(v1: Vec2, v2: Vec2): number;
	static applyMat3(v: Vec2, m: Mat): Vec2;
	static lerp(v1: Vec2, v2: Vec2, t: number): Vec2;
	static rotate(v: Vec2, center: Vec2, theta: number): Vec2;
	static equals(v1: Vec2, v2: Vec2, precision?: number): boolean;
	static getDistance(v1: Vec2, v2: Vec2): number;
	static getAngle(v1: Vec2, v2: Vec2): number;
	static minMax(...values: Vec2[]): {
		min: Vec2;
		max: Vec2;
	};
	clone(): Vec2;
	set(x: number, y: number): Vec2;
	setFromVec2(vec2: Vec2): Vec2;
	multiplyByScalar(s: number): Vec2;
	addScalar(s: number): Vec2;
	getMagnitude(): number;
	getAngle(v: Vec2): number;
	normalize(): Vec2;
	add(v: Vec2): Vec2;
	subtract(v: Vec2): Vec2;
	dotProduct(v: Vec2): number;
	applyMat3(m: Mat): Vec2;
	lerp(v: Vec2, t: number): Vec2;
	rotate(center: Vec2, theta: number): Vec2;
	truncate(decimalDigits?: number): Vec2;
	equals(v: Vec2, precision?: number): boolean;
	toArray(): number[];
	toIntArray(): Int32Array;
	toFloatArray(): Float32Array;
	[Symbol.iterator](): Iterator<number>;
}
export declare class Mat3 implements Mat {
	readonly length = 9;
	private readonly _matrix;
	get x_x(): number;
	get x_y(): number;
	get x_z(): number;
	get y_x(): number;
	get y_y(): number;
	get y_z(): number;
	get z_x(): number;
	get z_y(): number;
	get z_z(): number;
	constructor();
	static fromMat3(m: Mat3): Mat3;
	static fromMat4(m: Mat): Mat3;
	static from4Vec2(aMin: Vec2, aMax: Vec2, bMin: Vec2, bMax: Vec2, noRotation?: boolean): Mat3;
	static multiply(m1: Mat3, m2: Mat3): Mat3;
	static multiplyScalar(m: Mat3, s: number): Mat3;
	static transpose(m: Mat3): Mat3;
	static invert(m: Mat3): Mat3;
	static buildScale(x: number, y?: number): Mat3;
	static buildRotation(theta: number): Mat3;
	static buildTranslate(x: number, y: number): Mat3;
	static equals(m1: Mat3, m2: Mat3, precision?: number): boolean;
	clone(): Mat3;
	set(...elements: number[]): Mat3;
	reset(): Mat3;
	setFromMat3(m: Mat3): Mat3;
	setFromMat4(m: Mat): Mat3;
	multiply(m: Mat3): Mat3;
	multiplyScalar(s: number): Mat3;
	transpose(): Mat3;
	invert(): Mat3;
	getDeterminant(): number;
	getTRS(): {
		t: Vec2;
		r: number;
		s: Vec2;
	};
	truncate(decimalDigits?: number): Mat3;
	equals(m: Mat3, precision?: number): boolean;
	applyScaling(x: number, y?: number): Mat3;
	applyTranslation(x: number, y: number): Mat3;
	applyRotation(theta: number): Mat3;
	toArray(): number[];
	toIntArray(): Int32Array;
	toFloatArray(): Float32Array;
	toIntShortArray(): Int32Array;
	toFloatShortArray(): Float32Array;
	[Symbol.iterator](): Iterator<number>;
}
export declare class Vec3 implements Vec {
	readonly length = 3;
	x: number;
	y: number;
	z: number;
	constructor(x?: number, y?: number, z?: number);
	static multiplyByScalar(v: Vec3, s: number): Vec3;
	static addScalar(v: Vec3, s: number): Vec3;
	static normalize(v: Vec3): Vec3;
	static add(v1: Vec3, v2: Vec3): Vec3;
	static subtract(v1: Vec3, v2: Vec3): Vec3;
	static dotProduct(v1: Vec3, v2: Vec3): number;
	static crossProduct(v1: Vec3, v2: Vec3): Vec3;
	static onVector(v1: Vec3, v2: Vec3): Vec3;
	static onPlane(v: Vec3, planeNormal: Vec3): Vec3;
	static applyMat3(v: Vec3, m: Mat): Vec3;
	static applyMat4(v: Vec3, m: Mat): Vec3;
	static lerp(v1: Vec3, v2: Vec3, t: number): Vec3;
	static equals(v1: Vec3, v2: Vec3, precision?: number): boolean;
	static getDistance(v1: Vec3, v2: Vec3): number;
	static getAngle(v1: Vec3, v2: Vec3): number;
	clone(): Vec3;
	set(x: number, y: number, z: number): Vec3;
	setFromVec3(v: Vec3): Vec3;
	multiplyByScalar(s: number): Vec3;
	addScalar(s: number): Vec3;
	getMagnitude(): number;
	getAngle(v: Vec3): number;
	normalize(): Vec3;
	add(v: Vec3): Vec3;
	subtract(v: Vec3): Vec3;
	dotProduct(v: Vec3): number;
	crossProduct(v: Vec3): Vec3;
	onVector(v: Vec3): Vec3;
	onPlane(planeNormal: Vec3): Vec3;
	applyMat3(m: Mat): Vec3;
	applyMat4(m: Mat): Vec3;
	lerp(v: Vec3, t: number): Vec3;
	truncate(decimalDigits?: number): Vec3;
	equals(v: Vec3, precision?: number): boolean;
	toArray(): number[];
	toIntArray(): Int32Array;
	toFloatArray(): Float32Array;
	[Symbol.iterator](): Iterator<number>;
}
export declare class Quaternion {
	x: number;
	y: number;
	z: number;
	w: number;
	constructor(x?: number, y?: number, z?: number, w?: number);
	static fromRotationMatrix(m: Mat): Quaternion;
	static fromEuler(e: EulerAngles): Quaternion;
	static fromVec3Angle(v: Vec3, theta: number): Quaternion;
	static fromVec3s(v1: Vec3, v2: Vec3): Quaternion;
	static normalize(q: Quaternion): Quaternion;
	static invert(q: Quaternion): Quaternion;
	static dotProduct(q1: Quaternion, q2: Quaternion): number;
	static getAngle(q1: Quaternion, q2: Quaternion): number;
	static multiply(q1: Quaternion, q2: Quaternion): Quaternion;
	static slerp(q1: Quaternion, q2: Quaternion, t: number): Quaternion;
	static equals(q1: Quaternion, q2: Quaternion, precision?: number): boolean;
	clone(): Quaternion;
	set(x: number, y: number, z: number, w: number): Quaternion;
	setFromVec3s(v1: Vec3, v2: Vec3): Quaternion;
	setFromQ(q: Quaternion): Quaternion;
	setFromRotationMatrix(m: Mat): Quaternion;
	setFromEuler(e: EulerAngles): Quaternion;
	setFromVec3Angle(v: Vec3, theta: number): Quaternion;
	getMagnitude(): number;
	normalize(): Quaternion;
	invert(): Quaternion;
	dotProduct(q: Quaternion): number;
	getAngle(q: Quaternion): number;
	multiply(q: Quaternion): Quaternion;
	slerp(q: Quaternion, t: number): Quaternion;
	equals(q: Quaternion, precision?: number): boolean;
}
export declare class Mat4 implements Mat {
	readonly length = 16;
	private _matrix;
	get x_x(): number;
	get x_y(): number;
	get x_z(): number;
	get x_w(): number;
	get y_x(): number;
	get y_y(): number;
	get y_z(): number;
	get y_w(): number;
	get z_x(): number;
	get z_y(): number;
	get z_z(): number;
	get z_w(): number;
	get w_x(): number;
	get w_y(): number;
	get w_z(): number;
	get w_w(): number;
	constructor();
	static fromMat4(m: Mat4): Mat4;
	static fromTRS(t: Vec3, r: Quaternion, s: Vec3): Mat4;
	static fromQuaternion(q: Quaternion): Mat4;
	static multiply(m1: Mat4, m2: Mat4): Mat4;
	static multiplyScalar(m: Mat4, s: number): Mat4;
	static transpose(m: Mat4): Mat4;
	static invert(m: Mat4): Mat4;
	static lookAt(source: Vec3, target: Vec3, up: Vec3): Mat4;
	static buildScale(x: number, y?: number, z?: number): Mat4;
	static buildRotationX(theta: number): Mat4;
	static buildRotationY(theta: number): Mat4;
	static buildRotationZ(theta: number): Mat4;
	static buildTranslate(x: number, y: number, z: number): Mat4;
	static buildOrthographic(near: number, far: number, left: number, right: number, bottom: number, top: number): Mat4;
	static buildPerspective(near: number, far: number, fov: number, aspectRatio: number): Mat4;
	static buildPerspective(near: number, far: number, left: number, right: number, bottom: number, top: number): Mat4;
	static equals(m1: Mat4, m2: Mat4, precision?: number): boolean;
	clone(): Mat4;
	set(...elements: number[]): Mat4;
	reset(): Mat4;
	setFromMat4(m: Mat4): Mat4;
	setFromTRS(t: Vec3, r: Quaternion, s: Vec3): Mat4;
	setFromQuaternion(q: Quaternion): Mat4;
	multiply(mat: Mat4): Mat4;
	multiplyScalar(s: number): Mat4;
	transpose(): Mat4;
	invert(): Mat4;
	getDeterminant(): number;
	getTRS(): {
		t: Vec3;
		r: Quaternion;
		s: Vec3;
	};
	truncate(decimalDigits?: number): Mat4;
	equals(m: Mat4, precision?: number): boolean;
	applyScaling(x: number, y?: number, z?: number): Mat4;
	applyTranslation(x: number, y: number, z: number): Mat4;
	applyRotation(axis: "x" | "y" | "z", theta: number): Mat4;
	toArray(): number[];
	toIntArray(): Int32Array;
	toFloatArray(): Float32Array;
	[Symbol.iterator](): Iterator<number>;
}
export declare class Plane {
	normal: Vec3;
	d: number;
	get point(): Vec3;
	constructor(normal?: Vec3, d?: number);
	static equals(p1: Plane, p2: Plane, precision?: number): boolean;
	static fromNormalAndPoint(normal: Vec3, pointOnPlane: Vec3): Plane;
	static fromVec3s(a: Vec3, b: Vec3, c: Vec3): Plane;
	static applyMat4(p: Plane, m: Mat): Plane;
	static multiplyByScalar(p: Plane, s: number): Plane;
	static translate(p: Plane, v: Vec3): Plane;
	static projectPoint(p: Plane, v: Vec3): Vec3;
	clone(): Plane;
	set(normal: Vec3, d: number): Plane;
	setFromNormalAndPoint(normal: Vec3, pointOnPlane: Vec3): Plane;
	setFromPoints(a: Vec3, b: Vec3, c: Vec3): Plane;
	applyMat4(m: Mat): Plane;
	normalize(): Plane;
	multiplyByScalar(s: number): Plane;
	translate(v: Vec3): Plane;
	equals(p: Plane, precision?: number): boolean;
	getDistanceToPoint(v: Vec3): number;
	projectPoint(v: Vec3): Vec3;
}
export declare class Segment {
	a: Vec3;
	b: Vec3;
	constructor(a: Vec3, b: Vec3);
	static fromLine(s: Segment): Segment;
	static applyMat4(s: Segment, m: Mat): Segment;
	static equals(s1: Segment, s2: Segment): boolean;
	clone(): Segment;
	set(a: Vec3, b: Vec3): Segment;
	setFromLine(s: Segment): Segment;
	getCenter(): Vec3;
	getDelta(): Vec3;
	getLength(): number;
	applyMat4(m: Mat): Segment;
	equals(s: Segment, precision?: number): boolean;
}
export declare class Triangle {
	a: Vec3;
	b: Vec3;
	c: Vec3;
	constructor(a: Vec3, b: Vec3, c: Vec3);
	static fromTriangle(t: Triangle): Triangle;
	static equals(t1: Triangle, t2: Triangle, precision?: number): boolean;
	clone(): Triangle;
	set(a: Vec3, b: Vec3, c: Vec3): void;
	setFromTriangle(t: Triangle): Triangle;
	getArea(): number;
	getCenter(): Vec3;
	getNormal(): Vec3;
	getBary(v: Vec3): Vec3;
	getUV(v: Vec3, uvA: Vec2, uvB: Vec2, uvC: Vec2): Vec2;
	valid(v: Vec3): boolean;
	contains(v: Vec3): boolean;
	equals(t: Triangle, precision?: number): boolean;
}
export declare class Vec4 implements Vec {
	readonly length = 4;
	x: number;
	y: number;
	z: number;
	w: number;
	constructor(x?: number, y?: number, z?: number, w?: number);
	static fromVec3(v: Vec3): Vec4;
	static multiplyByScalar(v: Vec4, s: number): Vec4;
	static addScalar(v: Vec4, s: number): Vec4;
	static normalize(v: Vec4): Vec4;
	static add(v1: Vec4, v2: Vec4): Vec4;
	static subtract(v1: Vec4, v2: Vec4): Vec4;
	static dotProduct(v1: Vec4, v2: Vec4): number;
	static applyMat4(v: Vec4, m: Mat): Vec4;
	static lerp(v1: Vec4, v2: Vec4, t: number): Vec4;
	static equals(v1: Vec4, v2: Vec4, precision?: number): boolean;
	clone(): Vec4;
	set(x: number, y: number, z: number, w: number): Vec4;
	setFromVec3(v: Vec3): void;
	setFromVec4(v: Vec4): Vec4;
	multiplyByScalar(s: number): Vec4;
	addScalar(s: number): Vec4;
	getMagnitude(): number;
	normalize(): Vec4;
	add(v: Vec4): Vec4;
	subtract(v: Vec4): Vec4;
	dotProduct(v: Vec4): number;
	applyMat4(m: Mat): Vec4;
	lerp(v: Vec4, t: number): Vec4;
	truncate(decimalDigits?: number): Vec4;
	equals(v: Vec4, precision?: number): boolean;
	toArray(): number[];
	toIntArray(): Int32Array;
	toFloatArray(): Float32Array;
	[Symbol.iterator](): Iterator<number>;
}

export {};
